<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello My Blog!</title>
    <url>/2025/05/18/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>写这个博客的初衷</title>
    <url>/2025/05/18/%E5%86%99%E8%BF%99%E4%B8%AA%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%88%9D%E8%A1%B7/</url>
    <content><![CDATA[<h1 id="为什么要写这个博客？"><a href="#为什么要写这个博客？" class="headerlink" title="为什么要写这个博客？"></a>为什么要写这个博客？</h1><p>这是我的第三个个人博客。<br>第一个博客是在学前端的时候，建立的，为了练手，可惜没有太多更新，就停止了。<br>第二个博客也没有写多久，就停止了。<br>这是第三个博客，我想让它成为记录我生活的侧影，也作为某种时光流逝的证明。<br>这个博客主要以技术为主，也掺杂一些个人记录和杂感。它是属于我知识库。<br>在写博客的同时，我也想要更好的记录自己的生活。</p>
<h1 id="Pele是谁？"><a href="#Pele是谁？" class="headerlink" title="Pele是谁？"></a>Pele是谁？</h1><p>Pele是夏威夷火山的女神。一时想不出名字，就把这个博客叫做，pele的博客。<br>这也是我对生活的期望，能如火一般发光发热，如火一般流淌和绽放。</p>
<h1 id="这个博客怎么建立的？"><a href="#这个博客怎么建立的？" class="headerlink" title="这个博客怎么建立的？"></a>这个博客怎么建立的？</h1><p>使用Github Page + Hexo + NexT 建立的。<br>花费1个小时，即使小白也可以简单部署。<br>具体部署方式，我写第一个博客的时候，写了全部步骤，链接如下：<a href="https://sajlle.github.io/2023/04/15/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2%EF%BC%9F/">https://sajlle.github.io/2023/04/15/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2%EF%BC%9F/</a></p>
]]></content>
      <categories>
        <category>个人记录</category>
      </categories>
      <tags>
        <tag>博客介绍</tag>
      </tags>
  </entry>
  <entry>
    <title>多个不同账号，老号密码忘记，新号注册丢失数据，该怎么办？</title>
    <url>/2025/05/22/%E6%95%B0%E6%8D%AE%E6%97%A0%E6%B3%95%E6%89%BE%E5%9B%9E%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="我踩过的坑"><a href="#我踩过的坑" class="headerlink" title="我踩过的坑"></a>我踩过的坑</h1><p>从大学到现在，我换了四个电脑，一个iPad，两个手机。我注册账号比较随意，拿起哪个邮箱就注册哪个账号。导致我连着注册了三次steam，两次Ubisoft，两次epic。</p>
<p>第一次注册steam，我用了一个废弃QQ邮箱，结果买了几个游戏之后，注册邮箱失效，我的密码也忘记了，这个账号就废了。当然游戏也没了。</p>
<p>此等经历在Ubisoft和epic上接连重复，导致我损失了之前的游戏进度+游戏账号。</p>
<p>但是我还没有长记性，后续再注册账号的时候，还是使用根本不靠谱的邮箱+随意的设定密码。结果忘记密码，邮箱又失效，绑定的手机号码又换了，很多用了很多年的账号无法找回，数据丢失。</p>
<h1 id="改变的契机"><a href="#改变的契机" class="headerlink" title="改变的契机"></a>改变的契机</h1><p>没有好好记录密码，让我感到最糟糕的一次是，我给自己的电脑设置了BIOS锁，顺便还设置了一个HDD锁。设置完密码之后，我感到自己永远不会忘记当时突发奇想想到的密码，于是只草草记下了HDD密码，没有记录BIOS密码，最终导致我后期无法使用BIOS修改启动项。</p>
<p>后来我写Java项目的时候，要用虚拟机，需要到BIOS中改设置，但是失败了。于是这个项目，我损失了200¥买了一个云服务器，折腾许久。</p>
<p>但是没有BIOS锁毕竟不是长久之计。</p>
<p>后续我换了新的电脑，因为这段轻率改密码导致的长久不便，我便养成了一个随时把密码记到小本本上的习惯。</p>
<h1 id="密码管理，我的解决办法"><a href="#密码管理，我的解决办法" class="headerlink" title="密码管理，我的解决办法"></a>密码管理，我的解决办法</h1><p>我最近同时换了手机，手表，电脑，也申请了新邮箱。</p>
<p>这次我注册的所有新账号，都不再用不可找回的邮箱了，比如微软的outlook，我用它注册了多个游戏账号，但是因为该邮箱被封，我的游戏账号无法找回了。</p>
<p>我会把重要的账号密码，记录到一个小本本上，不管哪天换了设备，我都可以通过小本本的密码登陆这个账号。</p>
<p>当然，每次找小本本看密码，当然非常不方便，我现在使用密码管理工具来管理密码。</p>
<p>因为我最近的设备都是苹果的，就干脆用自带的密码软件管理密码，同时密码在所有的苹果设备上同步。</p>
<p>我认为这也是使用同品牌手机电脑的优势，可以跨设备共享隐私信息。</p>
<p>我之前用的win本+安卓手机，品牌不互通，别说密码，传文件都费劲，要么登陆微信传文件，要么直接拉一根数据线传文件，要么直接用U盘传文件。</p>
<p>现在用苹果的设备，可以直接隔空互传，不需要拉数据线或者下载第三方软件了，方便了很多。</p>
<p>不过使用苹果设备也有缺点，就是密码软件中记录的密码，在Safari浏览器中可以简单方便的使用，但是换到谷歌浏览器中，就无法使用密码软件记录的密码了。</p>
<p>所以我现在不管是登陆GitHub还是openAI，都尽量选Safari而不是谷歌。</p>
<p>现在新注册的账号，可以使用这些方式，确保账户不丢失。但是那些老账号该怎么办呢？</p>
<p>比如我的一个B站账号，用旧手机号注册的，旧手机号注销了，无法通过密码登陆。如果登陆新设备，需要验证手机号，但是我现在无法验证手机号，所以只能在旧电脑上登陆这个账号。</p>
<p>对于这些旧账号，要么旧设备上登陆，登陆新设备的时候用旧设备扫码授权。要么只能在旧设备上让它独美了。</p>
<p>不过提个醒，如果账号开通了创作激励，还是一开始就用靠谱的手机号和邮箱注册，不然就会如我这个旧账号一样尴尬。</p>
<h1 id="总结一下解决办法"><a href="#总结一下解决办法" class="headerlink" title="总结一下解决办法"></a>总结一下解决办法</h1><ol>
<li>使用靠谱的手机号+邮箱注册账号</li>
<li>使用密码管理工具管理密码</li>
<li>重要的账号信息，记录小本本</li>
<li>尽量使用同品牌的全家桶，设备之间账号共享+数据传输更方便</li>
<li>旧账号可以转移到新设备尽量转移，无法转移+找回，只能使用旧设备独美</li>
<li>对于涉及到金钱+收入的账号，一开始要计划好如何验证+找回，且用长期邮箱+手机号注册，不要用无法找回的邮箱OR即将更换的手机号注册</li>
</ol>
]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>数据同步</tag>
      </tags>
  </entry>
  <entry>
    <title>windows8年用户，为何转投Mac？聊聊我对Mac的体验！</title>
    <url>/2025/05/22/windows8%E5%B9%B4%E7%94%A8%E6%88%B7%EF%BC%8C%E4%B8%BA%E4%BD%95%E8%BD%AC%E6%8A%95Mac%EF%BC%9F%E8%81%8A%E8%81%8A%E6%88%91%E5%AF%B9Mac%E7%9A%84%E4%BD%93%E9%AA%8C%EF%BC%81/</url>
    <content><![CDATA[<h1 id="8年windows用户，为啥要开始自讨苦吃换Mac？"><a href="#8年windows用户，为啥要开始自讨苦吃换Mac？" class="headerlink" title="8年windows用户，为啥要开始自讨苦吃换Mac？"></a>8年windows用户，为啥要开始自讨苦吃换Mac？</h1><p>自从2017年开始，因为上大学，我爸爸给我买了我的第一台笔记本。在本地的一个小城，一个犄角旮旯的电脑城里，连WIFI都只会读成“外翻”的爸爸，给我选了一台他所知道的最好的电脑品牌的电脑，联想小新锐7000。这是一台游戏本，价格5400，因为没有预装正版系统+正版的Office，老板给我们便宜了200块，最终5200块，拿下了这个看起来又黑又重，但是配置还属中游的游戏本。</p>
<p>这个电脑被我拿来剪辑，编程，跑3dMax，写论文，下破解游戏，装双系统。大学的我正是时间不值钱，但是颇爱捣鼓的人，什么新鲜东西都想试试。最新版的游戏也想玩，但是裤兜比脸干净，怎么办呢？下载盗版。</p>
<p>破解版游戏，破解版软件，破解版工具，开各种自己不懂的权限，钱是我省了，但是代价留给了我的电脑。有一段时间，我的电脑简直是神仙打架，我不得不多次重装系统，来彻底清除这些问题。</p>
<p>但是，因为第七年的时候，我给电脑设置了BIOS锁，然后忘记了密码。这个电脑不仅不能重装系统，连虚拟机也不能装了。我只能简单的擦除磁盘，然后下载一个malwares来做个简单的病毒扫描。</p>
<p>我勉强用这个电脑去写文档，去跑单体项目，去做简单的剪辑，但是每次打开电脑，风扇就开始大声抗议，我明明只是开了一个文件夹+一个markdown文件，风扇就开始叫。一开始我只是觉得可能被挖矿了，但是杀软查了查，只查到一个格式工厂的遗毒，删了这个软件之后，这个老游戏本还是一开机就用风扇抗议我的所有行为。</p>
<p>我不得不承认，是这台电脑已经落伍了，跟不上时代了，就像买它的那天，那个犄角旮旯的电脑城，如今一样开始门可罗雀。</p>
<p>于是我不再纠结它的风扇呼呼啦啦的响声，不再试图在它的芯片+CPU无法承载的程度上，去跑那些它几乎无法跑的程序和游戏。</p>
<p>老电脑落伍了，我该换新的电脑，换哪一个品牌呢？我不知道。</p>
<h1 id="不是因为需要Mac而换Mac，只是因为想凑齐苹果全家桶，所以换了Mac"><a href="#不是因为需要Mac而换Mac，只是因为想凑齐苹果全家桶，所以换了Mac" class="headerlink" title="不是因为需要Mac而换Mac，只是因为想凑齐苹果全家桶，所以换了Mac"></a>不是因为需要Mac而换Mac，只是因为想凑齐苹果全家桶，所以换了Mac</h1><p>老电脑行将就木，可是我还要用电脑写项目，写文档，改简历。我不能没有电脑。</p>
<p>下一个电脑我该换哪个品牌呢？因为使用老电脑的时候，idea导入pom文件，加载配置的时间至少20分钟。彼时我被这种钝刀子割肉的编程感觉折磨，于是我暗下决心，下一台电脑，一定要换我能力范围之内，最好的电脑。于是在等一个单体项目加载配置的20分钟里，我拿手机查了无数遍什么电脑性能最好，我中意的是惠普的暗影精灵。</p>
<p>可是我最终没有买暗影精灵，虽然它的价格一万多，和MacBook Pro的价格不相上下。</p>
<p>真的花钱买新电脑的时候，电脑的卡顿已经成了我生活中最微不足道的问题。</p>
<p>今年春天，我在家的学习之路也要给一个最终的交代了。可是我并没心思去找新的工作。我觉得卡住了。我需要一个新的东西给我一点惊喜。</p>
<p>于是我买了苹果手机，最乞丐版本的，是一个深绿色的手机。我拿到这个手机之后玩了很久，IOS系统确实跟我之前用的安卓不同，新鲜感的驱使下，我连着写了三天的使用感受，没有人看，但是我写的很开心。</p>
<p>有了手机，我就又买了手表，手表很好看。其实手表，我不确定是否刚需。我已经有一个小米手环了，它续航长，耐久，虽然不好看，但是该有的功能都有。可是我总觉得缺了点什么。去年小米发布了新的手环和手表，我很想要那个400¥的小米手环9Pro，不是因为它的功能，而是它很像我中意的Apple Watch。但是当时我没有苹果手机，所以买了苹果手表也没用。我就把主意打到了小米手环9Pro上。</p>
<p>但是我最终没有买小米手环9Pro，不是因为它不好。因为我知道买了也不会满意。因为我想要的不是一个替代版本的Apple Watch。我想要的不是一个退而求次的版本的小米版的看起来像Apple Watch，实际根本不是的手环。</p>
<p>于是这个需求被压制了，直到今年我做了一个决定，买了苹果手机。拿到快递的那一刻，我有点惴惴不安，快递员准备充分，帮我拆了包装，看到里面那个非常简装的小盒子上，印着苹果的logo，我觉得不可思议。</p>
<p>那天送货的时候天色晚了，我边吃饭边心不在焉的等电话。那个昏暗的，下着小雨的晚上，我拿到了我的苹果手机，这个跟我的生活实在太不搭噶的产品。</p>
<p>有了苹果手机，就没有买Apple Watch的阻力了。于是买了苹果手机的第7天，我买了Apple Watch。我告诉自己，我最近睡不好，我需要测试心电图，可是真的需要吗？买了之后，我只是极少用它测试心电图。</p>
<p>但这对我来说是一种自我确证，我通过换苹果手机，换苹果手表，没有继续在消费上退而求其次，来确证自己值得更好的东西。</p>
<p>就像那段时间，我的生活充斥了各种糟糕的事情，我一开始只是意气用事，想要证明，就算生活这么糟糕，我也配得上最好的东西。于是我下单了一个并不实惠，性价比不高的Apple Watch，而不是下单那个性价比更高，甚至可以简单作为Apple Watch替代品的小米手环。虽然它们外表很像，但是我不要退而求其次了。</p>
<p>有了Apple Watch，我对苹果的产品大致什么样也有数了。当时我打算整理一个物流项目，这个项目有二十几个微服务，我跟GPT聊天，让它给我建议，GPT也丝毫不含糊，直接忽悠我上MacBook Pro最高配。</p>
<p>当然，我没那么多钱，但是也没多想。因为GPT的建议给我一种先入为主的印象，我得上MacBook Pro才行，虽然GPT的建议不实际，但是唯一给对的建议是买黑色的。因为白色的MacBook上配的那个黑色键盘怎么看怎么别扭。所以黑色的乞丐版MacBook Pro到手之后，我唯一庆幸的是，买了黑色，看着更顺眼一些罢了。</p>
<p>后续我再去比价，发现我买乞丐版MacBook Pro的钱，可以买MacBook Air的中配版，24 + 512的版本，两者芯片都一样的。处理器核数也一样。那么MacBook Pro乞丐版相比MacBook Air中等配置版，有啥区别呢？唯一的区别是更好的扬声器+更好的屏幕。可这些不是我的刚需。</p>
<p>上了Mac之后，我馋的隔空传文件+密码共享+iPad+iPhone+Apple Watch联动，确实不错，而且系统是非常流畅，屏幕素质确实非常的硬，扬声器的声效比我之前的八年老联想强的不止一星半点。</p>
<p>苹果全家桶，确实某种程度上，是一种身份的迷思。我没有的时候，我看那些软文，以及使用体验，感觉买了之后会很好，好到可以解决我生活中所有和电子设备相干或者不相干的问题。但是买到手之后，这些迷思就一一破解。</p>
<h1 id="和Win相比，Mac的优缺点"><a href="#和Win相比，Mac的优缺点" class="headerlink" title="和Win相比，Mac的优缺点"></a>和Win相比，Mac的优缺点</h1><p>先说优点。</p>
<p>上了Mac之后，第一个感觉是，设计足够好看。虽然我的联想win本也是黑色的，但是和Mac的外观给人的感觉极为不同，Mac的设计很精致。联想老本看起来粗蠢，虽然它性价比很高，也足够实用。</p>
<p>第二个感觉是，屏幕确实不错，看了两天Mac之后，再去看我之前的720Pwin本，感觉屏幕亮度+清晰度，被Mac远远甩开。</p>
<p>第三个感觉是，扬声器不错。本来拿到iPhone，我第一件事就是放歌曲。iPhone放歌曲足够让我惊艳了，但是Mac的音效比iPhone又强上很多。</p>
<p>第四个感觉是，反应快+灵敏。不管是运行Xcode还是idea，基本上不卡顿。</p>
<p>第五个感觉是，触控板极度灵敏。如果只做简单文档+写代码，可以完全不要鼠标。</p>
<p>第六个感觉是，Mac续航很长，可以跑8-9个小时无压力。而且开盖即可开始工作，不需要如win本那样，开盖程序要重新加载。</p>
<p>这些优势叠加在一起，造就了一种使用流畅的感觉，没有了使用win本那种小小的不便堆积而成的钝刀子割肉的感觉，就是Mac给我带来的惊喜。</p>
<p>但是Mac并不完美。</p>
<p>我用了这么久，还是觉得它有一些win本没有的缺点。</p>
<p>首先，文件管理系统不如win本清晰简洁。如果不用终端命令，几乎没办法直接访问隐藏文件。另一个关于文件管理系统让人抓狂的例子是，你没办法直接清晰简洁的访问一些文件夹，比如我在用户下建立了一个Blog文件夹，每次访问的时候都要从访达启动，非常麻烦。</p>
<p>其次，是Mac崩溃的时候假装没有崩溃，有时鼠标点不动了，我以为是程序问题，没怀疑到Mac本身，但是看日志，才发现不是程序问题，是当时Mac崩溃了。</p>
<p>最后，Mac上有些软件无法适配。比如一些虚拟机软件。比如一些阅读软件。</p>
<p>除此之外，Mac剩下都是优点。</p>
]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title>新手学习Java，怎么选择学习项目练手？哪些项目适合新人练手？</title>
    <url>/2025/05/23/%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0Java%EF%BC%8C%E6%80%8E%E4%B9%88%E9%80%89%E6%8B%A9%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E7%BB%83%E6%89%8B%EF%BC%9F%E5%93%AA%E4%BA%9B%E9%A1%B9%E7%9B%AE%E9%80%82%E5%90%88%E6%96%B0%E4%BA%BA%E7%BB%83%E6%89%8B%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>找项目非常坑，辗转多次还是选择自己做过能跑通的项目。</p>
<p>虽然只是写了一句吐槽的话，但是我真的在这上面浪费了很多时间。一开始追着最新的微服务项目跑，结果发现微服务配置繁琐，导入虚拟的一个操作，可以浪费我一个下午，新手一开始做这些复杂项目，非常打击自信心，不如从一些简单的单体项目开始。</p>
<p>以下是我遇到的一些项目误区：</p>
<h1 id="误区1：追最新的技术OR项目"><a href="#误区1：追最新的技术OR项目" class="headerlink" title="误区1：追最新的技术OR项目"></a>误区1：追最新的技术OR项目</h1><ol>
<li>文档不清晰</li>
<li>项目不一定能跑</li>
<li>虽然项目很优秀，但是你自己不一定能把配置好，跑起来。</li>
<li>各式神秘bug，找不到网络解决办法</li>
</ol>
<h1 id="误区2：从头开始重写选中的项目"><a href="#误区2：从头开始重写选中的项目" class="headerlink" title="误区2：从头开始重写选中的项目"></a>误区2：从头开始重写选中的项目</h1><ol>
<li>先把项目跑起来</li>
<li>找对应模块的增删改查逻辑，理解+能写</li>
<li>分析模块的技术选型+边界条件</li>
<li>分析项目的业务逻辑</li>
<li>给一个参照吧，新手拿到项目，复刻到本地跑通，就成功了50%，能写该项目的一两个模块的增删改查，成功了70%， 能把这两个模块从前端发请求，到后端处理数据的流程说清楚，成功了90%，最后可以说出为啥该项目选择这个技术，以及该方案的边界条件，就可以算成功100%了。</li>
</ol>
<h1 id="误区3：纠结细节-简单bug，不重视整体流程"><a href="#误区3：纠结细节-简单bug，不重视整体流程" class="headerlink" title="误区3：纠结细节+简单bug，不重视整体流程"></a>误区3：纠结细节+简单bug，不重视整体流程</h1><ol>
<li>新手学习项目，一定会遇到简单的bug，这些bug能查到解决办法就解决，不要太深入的挖掘</li>
<li>重点放在对框架的理解上，先不要深入细节，只要大致能明白这个技术OR框架走过哪些流程即可，在哪个环节发挥作用，解决了啥问题，技术的边界是哪里即可</li>
<li>不要把精力放到记忆的内容上，比如单纯的redis命令是什么，简单的常见命令没有记忆的价值，而且记忆了很快会忘记，把精力放到理解流程上。</li>
<li>不要一开始贪多，贪深，初学者不建议研究框架的底层细节，因为连流程都搞不清楚就深入细节，只是浪费时间+折磨自己。</li>
</ol>
<h1 id="最适合初学者写的项目要具备以下特征"><a href="#最适合初学者写的项目要具备以下特征" class="headerlink" title="最适合初学者写的项目要具备以下特征"></a>最适合初学者写的项目要具备以下特征</h1><ol>
<li>文档完备</li>
<li>教程完备</li>
<li>足够细节，没有硬伤</li>
<li>不是最新，而是最成熟，bug最少，业务逻辑清晰</li>
</ol>
<h1 id="给初学者的建议（也是我踩坑的经验总结）"><a href="#给初学者的建议（也是我踩坑的经验总结）" class="headerlink" title="给初学者的建议（也是我踩坑的经验总结）"></a>给初学者的建议（也是我踩坑的经验总结）</h1><ol>
<li>不要一上来就跟最新的项目</li>
<li>不要在基础不牢的时候跟业务复杂的项目</li>
<li>不要不顾自己水平，在没跑通单体项目的时候上微服务</li>
<li>写项目的时候，有侧重点，不是无脑crud，重点在业务逻辑，技术选型，边界条件，数据库+表设计</li>
<li>学习的时候不要纠结小参数，小bug，重要的是把整体的流程搞清楚。细节可以随后再补。精力不要放在一些需要记忆的内容上，比如常见命令，这些搜索引擎可以帮你完成，重要的是流程的理解。</li>
</ol>
]]></content>
      <categories>
        <category>Java学习</category>
      </categories>
      <tags>
        <tag>项目问题</tag>
      </tags>
  </entry>
  <entry>
    <title>VPN踩坑指南：我是怎么从不知道防火长城的存在到熟练使用VPN的？</title>
    <url>/2025/06/02/VPN%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8D%97%EF%BC%9A%E6%88%91%E6%98%AF%E6%80%8E%E4%B9%88%E4%BB%8E%E4%B8%8D%E7%9F%A5%E9%81%93%E9%98%B2%E7%81%AB%E9%95%BF%E5%9F%8E%E7%9A%84%E5%AD%98%E5%9C%A8%E5%88%B0%E7%86%9F%E7%BB%83%E4%BD%BF%E7%94%A8VPN%E7%9A%84%EF%BC%9F/</url>
    <content><![CDATA[<p>&#x2F;&#x2F;&#x2F; 禁忌的世界总是迷人的，当我翻墙之后，并不觉得多么令人惊讶，但是没有翻墙的时候，墙的禁忌本身就是一种魅力</p>
<p>&#x2F;&#x2F;&#x2F; 写这篇文章的时候，我不得不承认，我并不是一个行动派。我和其他爱夸夸其谈的人一样，总是在想合适的时机。所以那些甘于冒风险的人才让我觉得迷人。承担风险本身就是美感的体现，是关于勇气和判断力的美感。</p>
<h1 id="从什么时候开始知道有防火长城的存在？"><a href="#从什么时候开始知道有防火长城的存在？" class="headerlink" title="从什么时候开始知道有防火长城的存在？"></a>从什么时候开始知道有防火长城的存在？</h1><p>是在我上大学的时候。</p>
<p>本来我读的大学就是外语相关。我的舍友一直在用蓝灯，我也跟着她们知道了防火长城的存在。</p>
<p>关于这个舍友，她还告诉我可以把数据存到百度网盘上。虽然我不是太喜欢她，但是从她身上，我确实学到了很多东西，不管是剪辑，写公众号，都是她先起步，我跟着模仿她。</p>
<p>但是跟她在一起的时候，我特别不服气她。正是这股不服气+合不来的感觉，让我一路去追着她，模仿她。</p>
<p>当我知道防火长城存在的时候，也很好奇墙外是什么样子。</p>
<p>大一我知道防火长城的存在，但是直到大二我才有谷歌账号。我信息闭塞，等我知道蓝灯的时候，蓝灯已经穷途陌路了。</p>
<h1 id="翻墙的初体验，起始于蓝灯的500M免费流量"><a href="#翻墙的初体验，起始于蓝灯的500M免费流量" class="headerlink" title="翻墙的初体验，起始于蓝灯的500M免费流量"></a>翻墙的初体验，起始于蓝灯的500M免费流量</h1><p>当时是2017年，似乎Proton提供的免费VPN比较靠谱，但是我忽视了这些。</p>
<p>因为要做一些外语新闻的编译，找资料的时候不免要翻墙，所以对我来说，翻墙是刚需。</p>
<p>一次比较研究的课程上，这门课的老师给我们推荐expressVPN，说这个翻墙比较靠谱，他提醒我们，这个VPN的价格比较贵，我们可以合租。</p>
<p>等我意识到他的推荐是非常靠谱的时候，expressVPN已经传出一些跟红色公司勾兑的消息了。这和他教授我们课程的时候，已经过去了好几年。</p>
<p>我印象中这个老师看起来比较儒雅，温和，我喜欢他的课程，但是我做不好他的作业。</p>
<p>我受舍友的影响，她用翻墙VPN，我也把思路放到VPN上了，但是VPN的体验非常不好，我就开始琢磨，怎么翻墙比较好呢？</p>
<h1 id="VPN体验不好，我就自己搭VPS"><a href="#VPN体验不好，我就自己搭VPS" class="headerlink" title="VPN体验不好，我就自己搭VPS"></a>VPN体验不好，我就自己搭VPS</h1><p>正好我郁闷的时候，在学技术的时候，发现可以自己搭建VPS，于是我花了一个下午的时间，买了hostwinds的域名，照着教程选了西雅图的节点，自己还搭建成功了。</p>
<p>当时我只有python基础，也不懂任何网络知识。有的只是不值钱的时间，以及一身用不完的蛮力。那时候，我从来不怕自己失败，时间被浪费，因为我什么都没有，也不在乎会失去什么。</p>
<p>但是这个VPS我用了一个月就不再续期了。因为hostwind的ip地址经常被墙，所以它处于一个废弃的状态。</p>
<h1 id="VPS的IP经常被墙，于是我不再折腾，换了机场翻墙"><a href="#VPS的IP经常被墙，于是我不再折腾，换了机场翻墙" class="headerlink" title="VPS的IP经常被墙，于是我不再折腾，换了机场翻墙"></a>VPS的IP经常被墙，于是我不再折腾，换了机场翻墙</h1><p>那么搭建VPS价格不低，而且不稳定，那我还可以有哪些选择呢？</p>
<p>于是我在大量刷翻墙消息之后，选择了机场。</p>
<p>因为一开始没啥经验，我选机场的方式很简单，中文名的pass，机场主在中国的pass。国外公司的优先。外国人开的优先。当然这几种筛选方式都不靠谱。</p>
<p>等我意识到不靠谱的时候，又过去了几年。</p>
<p>不过用这些不靠谱的机场，确实让我感到隐约的不安。比如，我用Tag机场的时候，在whoer.net测试的时候，发现这个机场有webRTC泄漏。虽然它的价格不便宜，甚至可以比肩expressVPN，protonVPN。</p>
<p>但是当时就这么神奇，我宁可花更多钱用这个不靠谱的TAG机场，也不用protonVPN。因为我潜意识认为后者是非常贵的。我怎么形容这种印象呢？后者月付是外币，我就先入为主的认为美元计价的东西是比较贵的，所以即便用着比外币付款还贵的TAG，还是觉得proton更贵。</p>
<p>我意识到TAG不安全之后，立刻换了之前用过的JUST MY SOCKS，这家据说是vultr开的，5个节点，一个月500G流量。</p>
<p>我用回它的一个重要原因，是它据说是外国人开的。我之前用TAG，已经被中国人开的机场弄的不安心了。就算机场主人是海外国籍，我也不再用中国人开的VPN服务了。</p>
<p>但是JUST MY SOCKS，不能看流媒体，我就用了一个月，换了新发现的Vila VPN。Vila VPN的界面跟JUST MY SOCKS很像，而且都有一个月的退款政策。</p>
<p>有人说这是变态辣椒推荐的，靠谱。现在我不觉得这种评价是对的了。</p>
<p>因为变态辣椒不是搞技术的人，他虽然画讽刺漫画，但是这只能表示他的某些立场和观点和官方不同，不能保证他的人品，以及他在技术上的理解力是正确的。就算他人品不错也想要推荐靠谱的VPN，但是他缺乏技术理解力，就算有心也无法实现这种承诺。</p>
<p>用文字噱头或者和官方立场不同来暗示自己可靠，是很多小机场的营销手段。立场不等于技术。承诺+嘴炮表演不等于能力。</p>
<p>说回vila VPN。它当时有两种套餐，一种用的是思科的软件，一种用的是clash。我选了思科的软件。不选clash的原因是，clash非开源，如今clash已经是半残废了。</p>
<p>我现在选vpn+其他软件，都是开源优先。</p>
<p>但是当时我不这么想，我知道装了clash之后，我的电脑老是卡顿，而且我用tag和其他机场的时候，就是装clash用的。也许是clash沾染了我不喜欢的旧日的时光，于是我选了思科的软件套餐。我当时陷入了一个误区，当旧日的软件让我不安，那么陌生的软件就一定是好的。</p>
<p>但是选了思科的软件，确实令我感到安心一点。</p>
<p>我最终放弃了使用vila VPN，因为我闲的无聊的时候，翻阅隐私政策的时候，vila的隐私政策表示，具体的数据处理要根据子公司所在地的法律处理。但是它宣传的时候说自己是日本的公司。暗示顾客数据遵守日本的法律，不会被传输到国内处理。但是隐私政策则表示，母公司在日本没用，如果vilia没有披露自己在国内有子公司，那么用户的数据也会被传输到国内处理。因为它在营销上玩的小聪明，我没有继续使用vila。</p>
<h1 id="发现了机场的一些漏洞，不想再折腾，于是换回了VPN"><a href="#发现了机场的一些漏洞，不想再折腾，于是换回了VPN" class="headerlink" title="发现了机场的一些漏洞，不想再折腾，于是换回了VPN"></a>发现了机场的一些漏洞，不想再折腾，于是换回了VPN</h1><p>折了钱但是没有数据安全+方便，我决定不在vpn上省钱了。</p>
<p>我的隐私数据不重要，但是我不想泄漏。我觉得隐私关乎人的尊严。没有隐私就没有尊严。没人想要自己的数据被存储在自己不可控的地方。</p>
<p>我决定在vpn上多花钱之后，释然了很多，开始去看国外大厂的vpn。</p>
<p>我不喜欢年付价格和月付价格差别大的产品，所以最终没有选择express和surfshark。也许是之前吃了太多小机场+钓鱼vpn的亏，这些机场的一个特征就是，月付年付价格差别大。</p>
<p>最终我选了mullvad，这个我之前没听过名字的vpn。</p>
<p>选择这个vpn的理由是，月付年付价格一样。可以门罗币付款，门罗币是加密货币中最难追踪的一种。没有账号和密码，只有账户代码，账户可以随时删除。有明确的隐私政策。5年之内有过一些被官方突击检查没有交出用户数据的新闻。强制开启kil switch。</p>
<p>我实际花钱下来，发现mullvad价格并不高，甚至完全贵不过TAG。关于国外大厂VPN价格高的迷思，就这么破解了。</p>
<h1 id="为什么国产小机场数据不安全，服务差，还能运行的那么好？"><a href="#为什么国产小机场数据不安全，服务差，还能运行的那么好？" class="headerlink" title="为什么国产小机场数据不安全，服务差，还能运行的那么好？"></a>为什么国产小机场数据不安全，服务差，还能运行的那么好？</h1><p>踩了这么多坑之后，我发现我之前吃了那么多国产机场的亏，是因为销售这些VPN的人没有提任何数据安全的技术，这些人只是反复告诉用户，我的机场可以看流媒体，功能多样，但是最重要的数据安全没有说，甚至经常出现一些不该出现的漏洞。</p>
<p>而这些机场的用户讨论群中，只是在八卦，哪个机场倒闭了，哪个机场跑路了。如果有人提数据安全的问题，立刻有人说，翻墙就要遵规守矩，不要乱发言，不要越过红线。但是这真的对吗？你按照人的惯性去想，这绝对不对的，如果真的有问题，一个人的数据难调查，一个人的数据好调查，人的惯性是要那个数据方便调查的人当指标的，不是你说了什么，而是你被抓典型的成本如何。</p>
<p>我不知道是混在这些用户群的之中导致的，我在用国产小机场的时候，一些关于vpn和机场的知识被刻意的不被提起。</p>
<p>比如，vpn如果不设置kill switch开关，真实的ip地址会被泄露。比如，导入机场订阅的时候，也可能导入一些证书，如果你的设备装了不可信的证书，以后再怎么做数据安全措施也没有用。</p>
<p>等我换了信息来源，这些长久不被提起的知识，忽然被我发现了。</p>
<p>我觉得很惊讶，因为我花了很久去踩坑获取了这些知识，而对另一群人来说，这些东西不过是常识而已。</p>
<p>为什么这些数据不安全的机场可以开下去呢？</p>
<p>我的理解是，用户没有足够的科技知识和安全意识，所以他们要么不清楚小机场的技术漏洞，要么把数据安全放到最后，以省钱+好用优先。用户素质不够，导致他们可以大批量割韭菜。</p>
<p>另一方面是，机场的营销手段非常有效，绝口不提该有的安全措施，反而以便宜好用作为卖点。精准打击到了用户的需要：省钱+能用。毕竟相比虚无缥缈的数据安全，还是能省下这眼前的几块钱更重要。</p>
<p>其实这就跟淘宝上的一些200¥的奢侈品一样，买的人知道这个价格不可能买到对应的品牌，卖的人也知道这是假货。</p>
<p>买家和卖家都心知肚明，自己要的是什么，于是这样的廉价生意可以做到现在。</p>
<h1 id="未来我只会选择大厂的VPN，不会再用个人OR国产小机场了"><a href="#未来我只会选择大厂的VPN，不会再用个人OR国产小机场了" class="headerlink" title="未来我只会选择大厂的VPN，不会再用个人OR国产小机场了"></a>未来我只会选择大厂的VPN，不会再用个人OR国产小机场了</h1><p>再说vpn的未来，现在红线越来越收紧的情况下，小公司的VPN很难去保护用户的数据，所以未来我认为大厂的vpn更可信一些。但这不是绝对。不要有依赖心而丧失判断力。因为一切都在变。</p>
<p>clash已经删库跑路，v2ray我也不清楚是否靠谱，我觉得很不可思议。</p>
<p>2019年的时候，我还可以用bing不翻墙就搜索到v2ray，但是现在GitHub也几乎上不去了，更别说v2ray了。</p>
<p>时移世易，这一切都变的很快。我也变得很快。</p>
<p>我读大学的时候，可以花一个下午，手搓一个VPS，但是现在我不会这么干了。那个时候，我焦虑，但是也有使不完的牛劲，不害怕失败，也不害怕丢脸。那个时候，我的兜比脸干净，但是我有的是时间。</p>
<p>但是现在我不那么想了，我会花钱买vpn，也不会自己手搓VPS了。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>VPN</tag>
      </tags>
  </entry>
  <entry>
    <title>Python+Edge-TTS实现文字转语音功能！傻瓜式教学，有手就行！</title>
    <url>/2025/06/08/Python-Edge-TTS%E5%AE%9E%E7%8E%B0%E6%96%87%E5%AD%97%E8%BD%AC%E8%AF%AD%E9%9F%B3%E5%8A%9F%E8%83%BD%EF%BC%81%E5%82%BB%E7%93%9C%E5%BC%8F%E6%95%99%E5%AD%A6%EF%BC%8C%E6%9C%89%E6%89%8B%E5%B0%B1%E8%A1%8C%EF%BC%81/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近在家想要剪个视频，文本写好，但是缺乏配音，又不想自己上，怎么办呢？用文字转语音软件。浏览器搜索排名靠前的是讯飞，魔方语音。这两家我都用过，效果不错但是要付费。</p>
<p>因为要做的视频非商用视频，所以就选择自己写脚本文字转语音。</p>
<h1 id="方案介绍"><a href="#方案介绍" class="headerlink" title="方案介绍"></a>方案介绍</h1><p>使用微软Edge-TTS搭配python实现。完全免费，无需Azure订阅，适合轻量使用。</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>不需要API key，没有字符限制，使用简单，可以通过命令行调用。</p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li>依赖edge浏览器</li>
<li>不可商用</li>
<li>无法如Azure TTS一样可以精细控制</li>
</ul>
<h1 id="实现流程"><a href="#实现流程" class="headerlink" title="实现流程"></a>实现流程</h1><h2 id="傻瓜式测试版"><a href="#傻瓜式测试版" class="headerlink" title="傻瓜式测试版"></a>傻瓜式测试版</h2><p>我们先从最简单的步骤开始，测试最简单的文本，确定方案可用之后再上复杂的脚本。</p>
<h3 id="具体步骤如下"><a href="#具体步骤如下" class="headerlink" title="具体步骤如下"></a>具体步骤如下</h3><ol>
<li>下载edge浏览器</li>
<li>安装Python库</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip3 install edge-tts</span><br></pre></td></tr></table></figure>

<ol>
<li>查看支持的语音列表，运行以下命令查看所有语音列表</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">edge-tts --list-voices</span><br></pre></td></tr></table></figure>

<ol>
<li>如果有了目标语音，可以直接使用grep获取语音名称，作者喜欢晓晓的声音，所以测试使用的是晓晓</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">edge-tts --list-voices | grep XiaoxiaoNeural</span><br></pre></td></tr></table></figure>

<ol>
<li>使用命令行生成语音，测试功能是否正常</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">edge-tts --voice zh-CN-XiaoxiaoNeural --text <span class="string">&quot;你好，我是微软晓晓。&quot;</span> --write-media output.mp3</span><br><span class="line"><span class="comment"># --voice：指定语音（比如 `zh-CN-XiaoxiaoNeural`</span></span><br><span class="line"><span class="comment"># --text：要转换的文本</span></span><br><span class="line"><span class="comment"># --write-media：输出音频文件（mp3格式）</span></span><br></pre></td></tr></table></figure>

<h2 id="初级脚本版"><a href="#初级脚本版" class="headerlink" title="初级脚本版"></a>初级脚本版</h2><p>傻瓜式测试之后，发现功能可用。我们就可以写脚本了。</p>
<h3 id="Python脚本"><a href="#Python脚本" class="headerlink" title="Python脚本"></a>Python脚本</h3><p>初级脚本如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> edge_tts</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">generate_speech</span>(<span class="params">text, output_file</span>):</span><br><span class="line">    voice = <span class="string">&quot;zh-CN-XiaoxiaoNeural&quot;</span>  <span class="comment"># 使用晓晓语音</span></span><br><span class="line">    communicate = edge_tts.Communicate(text=text, voice=voice)</span><br><span class="line">    <span class="keyword">await</span> communicate.save(output_file)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用示例</span></span><br><span class="line">asyncio.run(generate_speech(<span class="string">&quot;你好，欢迎使用Edge TTS。&quot;</span>, <span class="string">&quot;output.mp3&quot;</span>))</span><br></pre></td></tr></table></figure>

<p>脚本讲解</p>
<ul>
<li>asyncio是python的异步IO库，涉及网络请求文件读写等需要等待的操作时，程序在等待的时候可以做其他事情<ul>
<li>核心概念<ul>
<li>async&#x2F;await来定义异步函数和等待异步操作</li>
<li>事件循环：驱动异步任务的引擎</li>
</ul>
</li>
</ul>
</li>
<li>代码解析<ul>
<li><p>我们定义了一个异步函数，使用async def来声明这个函数是异步函数。</p>
</li>
<li><p>这个函数的参数是</p>
<ul>
<li>text：需要语音转文字的文本</li>
<li>output_file：保存的文件名</li>
</ul>
</li>
<li><p>设置语音合成器</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">voice = <span class="string">&quot;zh-CN-XiaoxiaoNeural&quot;</span>  <span class="comment"># 使用晓晓语音</span></span><br><span class="line">communicate = edge_tts.Communicate(text=text, voice=voice)</span><br></pre></td></tr></table></figure>
<ul>
<li>edge_tts.Comunicate()可以创建一个语音合成任务</li>
<li>这一步不会立刻请求，而是返回一个协程对象（Coroutine）</li>
</ul>
</li>
<li><p>保存语音文件</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> communicate.save(output_file)</span><br></pre></td></tr></table></figure>
<ul>
<li>await等待异步操作完成，会真正触发语音合成，并且保存文件<ul>
<li>程序在此处会暂停，直到save完成，但是不会阻塞整个线程</li>
<li>如果合成成功，语音会保存到output_file</li>
</ul>
</li>
</ul>
</li>
<li><p>调用异步函数</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">asyncio.run(generate_speech(<span class="string">&quot;你好，欢迎使用Edge TTS。&quot;</span>, <span class="string">&quot;output.mp3&quot;</span>))</span><br></pre></td></tr></table></figure>
<ul>
<li>asyncio.run()启动事件循环并且运行异步函数<ul>
<li>它是异步程序的入口</li>
<li>执行完毕之后自动关闭事件循环</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="为什么-Edge-TTS-要用异步？"><a href="#为什么-Edge-TTS-要用异步？" class="headerlink" title="为什么 Edge TTS 要用异步？"></a><strong>为什么 Edge TTS 要用异步？</strong></h3><p>因为语音合成需要：</p>
<ol>
<li><p>向微软服务器发送请求（网络 I&#x2F;O）。</p>
</li>
<li><p>接收音频流并保存（文件 I&#x2F;O）。</p>
<p> 这些操作都是 <strong>耗时任务</strong>，用异步可以避免阻塞主程序。</p>
</li>
</ol>
<h3 id="调整语速"><a href="#调整语速" class="headerlink" title="调整语速"></a>调整语速</h3><p>Edge TTS 默认不支持直接调整语速，但可以通过 <strong>SSML（语音标记语言）</strong> 实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">text = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;speak version=&quot;1.0&quot; xmlns=&quot;http://www.w3.org/2001/10/synthesis&quot; xml:lang=&quot;zh-CN&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;prosody rate=&quot;fast&quot;&gt;这句话会说得更快。&lt;/prosody&gt;</span></span><br><span class="line"><span class="string">    &lt;prosody rate=&quot;slow&quot;&gt;这句话会说得更慢。&lt;/prosody&gt;</span></span><br><span class="line"><span class="string">&lt;/speak&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">asyncio.run(generate_speech(text, <span class="string">&quot;output_with_speed.mp3&quot;</span>))</span><br></pre></td></tr></table></figure>

<p>注： <code>rate=&quot;fast&quot;</code> &#x2F; <code>rate=&quot;slow&quot;</code>：调整语速（可选 <code>x-slow</code>, <code>slow</code>, <code>medium</code>, <code>fast</code>, <code>x-fast</code>）。</p>
<h3 id="如何批量转换文本？"><a href="#如何批量转换文本？" class="headerlink" title="如何批量转换文本？"></a>如何批量转换文本？</h3><p>使用Python脚本循环处理多个文本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">texts = [<span class="string">&quot;第一段话&quot;</span>, <span class="string">&quot;第二段话&quot;</span>, <span class="string">&quot;第三段话&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> i, text <span class="keyword">in</span> <span class="built_in">enumerate</span>(texts):</span><br><span class="line">    asyncio.run(generate_speech(text, <span class="string">f&quot;output_<span class="subst">&#123;i&#125;</span>.mp3&quot;</span>))</span><br></pre></td></tr></table></figure>

<h3 id="如何批量合成语音？"><a href="#如何批量合成语音？" class="headerlink" title="如何批量合成语音？"></a>如何批量合成语音？</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">batch_convert</span>(<span class="params">texts</span>):</span><br><span class="line">    tasks = []</span><br><span class="line">    <span class="keyword">for</span> i, text <span class="keyword">in</span> <span class="built_in">enumerate</span>(texts):</span><br><span class="line">        task = generate_speech(text, <span class="string">f&quot;output_<span class="subst">&#123;i&#125;</span>.mp3&quot;</span>)</span><br><span class="line">        tasks.append(task)</span><br><span class="line">    <span class="keyword">await</span> asyncio.gather(*tasks)  <span class="comment"># 并行执行所有任务</span></span><br><span class="line"></span><br><span class="line">texts = [<span class="string">&quot;语音1&quot;</span>, <span class="string">&quot;语音2&quot;</span>, <span class="string">&quot;语音3&quot;</span>]</span><br><span class="line">asyncio.run(batch_convert(texts))</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">asyncio.gather()</span><br></pre></td></tr></table></figure>

<p>会同时运行多个异步任务，比顺序执行快得多！</p>
<h2 id="后续改进"><a href="#后续改进" class="headerlink" title="后续改进"></a>后续改进</h2><p>我目前用到的功能是20秒的文本转语音，所以用不到长文本OR批量文本转语音，所以该脚本目前基本可以满足我的需要。</p>
<h3 id="简单场景的文字转语音需要改进的部分"><a href="#简单场景的文字转语音需要改进的部分" class="headerlink" title="简单场景的文字转语音需要改进的部分"></a>简单场景的文字转语音需要改进的部分</h3><ul>
<li><input disabled="" type="checkbox"> 添加读取文本的功能，从指定文件读取文本内容</li>
<li><input disabled="" type="checkbox"> 读取文本之后，切分文本的第一行为标题，剩余文本为语音转文字的内容</li>
<li><input disabled="" type="checkbox"> 保存文件的时候询问用户保存到哪个目录，否则保存到默认目录</li>
<li><input disabled="" type="checkbox"> 文本文件可以包含目录行，读取文本的时候切分到这一行，文本生成的时候，自动保存到该目录，如果为空，则保存到默认目录</li>
<li><input disabled="" type="checkbox"> 批量读取文件功能</li>
<li><input disabled="" type="checkbox"> 批量生成语音功能</li>
<li><input disabled="" type="checkbox"> 制作GUI界面</li>
<li><input disabled="" type="checkbox"> 本机上写简单的bash脚本，从读取文本到合成语音，到保存文件。</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>用python+vosk实现免费的视频转文字功能! 傻瓜式编码，小白也可操作！</title>
    <url>/2025/06/08/%E5%82%BB%E7%93%9C%E5%BC%8F%E7%BC%96%E7%A0%81%EF%BC%8C%E5%B0%8F%E7%99%BD%E4%B9%9F%E5%8F%AF%E6%93%8D%E4%BD%9C%EF%BC%81/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>之前剪辑的视频，脚本源文件丢了，想用视频文稿，确实有点麻烦，所以这次我们自己写个Python脚本实现免费的视频转文字。</p>
<h1 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h1><p>使用开源的vosk库+python，来写一个不超过30行的视频转文字软件。</p>
<h2 id="傻瓜式测试"><a href="#傻瓜式测试" class="headerlink" title="傻瓜式测试"></a>傻瓜式测试</h2><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><p>先确保电脑上装好了python和ffmpeg</p>
<ul>
<li><strong>Python 3.7+</strong>：确保已安装（<a href="https://www.python.org/downloads/">官网下载</a>）。</li>
<li>*<em><strong>FFmpeg</strong></em>：用于提取视频音频（<a href="https://ffmpeg.org/">安装指南</a>）：</li>
</ul>
<p>Mac用户可以使用homebrew安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install ffmpeg</span><br></pre></td></tr></table></figure>

<p>Win用户可以使用choco装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">choco install ffmpeg</span><br></pre></td></tr></table></figure>

<h3 id="安装vosk"><a href="#安装vosk" class="headerlink" title="安装vosk"></a>安装vosk</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip3 install vosk</span><br></pre></td></tr></table></figure>

<h3 id="下载语言模型"><a href="#下载语言模型" class="headerlink" title="下载语言模型"></a>下载语言模型</h3><ul>
<li>从 <a href="https://alphacephei.com/vosk/models">Vosk模型库</a> 选择模型（按需下载）：<ul>
<li><strong>中文模型</strong>：<code>vosk-model-small-zh-cn-0.22</code>（小型，推荐初试）</li>
<li><strong>高精度模型</strong>：<code>vosk-model-zh-cn-0.22</code>（更大，更准）</li>
</ul>
</li>
<li>解压后得到文件夹（如<code>vosk-model-small-zh-cn-0.22</code>），记住路径。</li>
</ul>
<h3 id="从视频提取音频"><a href="#从视频提取音频" class="headerlink" title="从视频提取音频"></a>从视频提取音频</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ffmpeg -i input.mp4 -vn -ar 16000 -ac 1 -c:a pcm_s16le audio.wav</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><code>ar 16000</code>：16kHz采样率（Vosk推荐）。</li>
<li><code>ac 1</code>：单声道（提升识别效率）。</li>
</ul>
<h3 id="音频转文本"><a href="#音频转文本" class="headerlink" title="音频转文本"></a>音频转文本</h3><p>创建脚本 <code>vosk_transcribe.py</code>：</p>
<p>脚本如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> vosk <span class="keyword">import</span> Model, KaldiRecognizer</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置模型路径（替换为你的模型文件夹路径）</span></span><br><span class="line">model_path = <span class="string">&quot;path/to/vosk-model-small-zh-cn-0.22&quot;</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(model_path):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;错误：模型路径不存在！请检查 <span class="subst">&#123;model_path&#125;</span>&quot;</span>)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载模型</span></span><br><span class="line">model = Model(model_path)</span><br><span class="line">recognizer = KaldiRecognizer(model, <span class="number">16000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取音频文件</span></span><br><span class="line">audio_file = <span class="string">&quot;audio.wav&quot;</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(audio_file):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;错误：音频文件 <span class="subst">&#123;audio_file&#125;</span> 不存在！&quot;</span>)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分段识别</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(audio_file, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    audio_data = f.read()</span><br><span class="line">    <span class="keyword">if</span> recognizer.AcceptWaveform(audio_data):</span><br><span class="line">        result = json.loads(recognizer.Result())</span><br><span class="line">        <span class="built_in">print</span>(result[<span class="string">&quot;text&quot;</span>])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;识别失败。&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取完整结果（含时间戳）</span></span><br><span class="line">result = json.loads(recognizer.FinalResult())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最终识别结果：&quot;</span>, result[<span class="string">&quot;text&quot;</span>])</span><br></pre></td></tr></table></figure>

<h3 id="运行脚本"><a href="#运行脚本" class="headerlink" title="运行脚本"></a>运行脚本</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3 vosk_transcribe.py</span><br></pre></td></tr></table></figure>

<h3 id="生成字幕文件"><a href="#生成字幕文件" class="headerlink" title="生成字幕文件"></a>生成字幕文件</h3><p>修改脚本以输出带时间戳的字幕（<code>.srt</code>）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> vosk <span class="keyword">import</span> Model, KaldiRecognizer, SetLogLevel</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">SetLogLevel(-<span class="number">1</span>)  <span class="comment"># 关闭日志输出</span></span><br><span class="line"></span><br><span class="line">model_path = <span class="string">&quot;path/to/vosk-model-small-zh-cn-0.22&quot;</span></span><br><span class="line">audio_file = <span class="string">&quot;audio.wav&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查文件</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(model_path) <span class="keyword">or</span> <span class="keyword">not</span> os.path.exists(audio_file):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;模型或音频文件缺失！&quot;</span>)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化</span></span><br><span class="line">model = Model(model_path)</span><br><span class="line">rec = KaldiRecognizer(model, <span class="number">16000</span>)</span><br><span class="line">rec.SetWords(<span class="literal">True</span>)  <span class="comment"># 启用单词级时间戳</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用FFmpeg实时流式处理（支持长音频）</span></span><br><span class="line">command = [<span class="string">&quot;ffmpeg&quot;</span>, <span class="string">&quot;-loglevel&quot;</span>, <span class="string">&quot;quiet&quot;</span>, <span class="string">&quot;-i&quot;</span>, audio_file,</span><br><span class="line">           <span class="string">&quot;-ar&quot;</span>, <span class="string">&quot;16000&quot;</span>, <span class="string">&quot;-ac&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;-f&quot;</span>, <span class="string">&quot;s16le&quot;</span>, <span class="string">&quot;-&quot;</span>]</span><br><span class="line">process = subprocess.Popen(command, stdout=subprocess.PIPE)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成SRT字幕</span></span><br><span class="line">srt_content = []</span><br><span class="line">index = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    data = process.stdout.read(<span class="number">4000</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(data) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> rec.AcceptWaveform(data):</span><br><span class="line">        result = json.loads(rec.Result())</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;result&#x27;</span> <span class="keyword">in</span> result:</span><br><span class="line">            words = result[<span class="string">&#x27;result&#x27;</span>]</span><br><span class="line">            start = words[<span class="number">0</span>][<span class="string">&#x27;start&#x27;</span>]</span><br><span class="line">            end = words[-<span class="number">1</span>][<span class="string">&#x27;end&#x27;</span>]</span><br><span class="line">            text = <span class="string">&#x27; &#x27;</span>.join([w[<span class="string">&#x27;word&#x27;</span>] <span class="keyword">for</span> w <span class="keyword">in</span> words])</span><br><span class="line">            srt_content.append(</span><br><span class="line">                <span class="string">f&quot;<span class="subst">&#123;index&#125;</span>\n&quot;</span></span><br><span class="line">                <span class="string">f&quot;<span class="subst">&#123;<span class="built_in">int</span>(start//<span class="number">3600</span>):02d&#125;</span>:<span class="subst">&#123;<span class="built_in">int</span>((start%<span class="number">3600</span>)//<span class="number">60</span>):02d&#125;</span>:<span class="subst">&#123;<span class="built_in">int</span>(start%<span class="number">60</span>):02d&#125;</span>,<span class="subst">&#123;<span class="built_in">int</span>((start%<span class="number">1</span>)*<span class="number">1000</span>):03d&#125;</span> --&gt; &quot;</span></span><br><span class="line">                <span class="string">f&quot;<span class="subst">&#123;<span class="built_in">int</span>(end//<span class="number">3600</span>):02d&#125;</span>:<span class="subst">&#123;<span class="built_in">int</span>((end%<span class="number">3600</span>)//<span class="number">60</span>):02d&#125;</span>:<span class="subst">&#123;<span class="built_in">int</span>(end%<span class="number">60</span>):02d&#125;</span>,<span class="subst">&#123;<span class="built_in">int</span>((end%<span class="number">1</span>)*<span class="number">1000</span>):03d&#125;</span>\n&quot;</span></span><br><span class="line">                <span class="string">f&quot;<span class="subst">&#123;text&#125;</span>\n\n&quot;</span></span><br><span class="line">            )</span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入SRT文件</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;output.srt&quot;</span>, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.writelines(srt_content)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;字幕已生成：output.srt&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="导入字幕到Final-Cut-Pro"><a href="#导入字幕到Final-Cut-Pro" class="headerlink" title="导入字幕到Final Cut Pro"></a>导入字幕到Final Cut Pro</h3><p>直接拖拽output.srt到时间轴，自动匹配音频轨道</p>
<h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ol>
<li>识别不准？</li>
</ol>
<ul>
<li>尝试更大的模型（如<code>vosk-model-zh-cn-0.22</code>）。</li>
<li>确保音频清晰（可用Audacity降噪）。</li>
</ul>
<ol start="2">
<li><strong>长音频处理失败</strong>？</li>
</ol>
<ul>
<li><p>分段处理音频（用FFmpeg拆分）：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ffmpeg -i audio.wav -f segment -segment_time 300 -c copy chunk_%03d.wav</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="3">
<li><strong>模型路径错误</strong>？</li>
</ol>
<ul>
<li>使用绝对路径（如<code>/Users/name/models/vosk-model-zh-cn-0.22</code>）。</li>
</ul>
<ol>
<li>进阶优化<ul>
<li>实时录音转写<ul>
<li>从麦克风实时输入（可以调用pyaudio库）</li>
</ul>
</li>
<li>批处理视频<ul>
<li>Python遍历文件夹，自动提取录音并转写</li>
</ul>
</li>
<li>GUI界面设计<ul>
<li><p>打包脚本为EXE</p>
<ul>
<li><p>安装PyInstaller</p>
</li>
<li><p>打包脚本命令：pyinstaller –onefile –windowed –icon&#x3D;app.ico vosk_transcribe.py</p>
<ul>
<li><code>-onefile</code>：生成单个 EXE 文件。</li>
<li><code>-windowed</code>：隐藏命令行窗口（适合 GUI 应用）。</li>
<li><code>-icon=app.ico</code>：自定义图标（需准备 <code>.ico</code> 文件）。</li>
</ul>
</li>
<li><p>处理依赖问题</p>
<ul>
<li><p>Vosk 模型文件需手动复制到 EXE 同级目录。</p>
<p>  在脚本中添加以下代码，确保打包后能找到模型：</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断是否是打包后的环境</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">getattr</span>(sys, <span class="string">&#x27;frozen&#x27;</span>, <span class="literal">False</span>):</span><br><span class="line">model_path = os.path.join(os.path.dirname(sys.executable), <span class="string">&quot;vosk-model-small-zh-cn-0.22&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">model_path = <span class="string">&quot;path/to/original/model&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>生成结果</strong>：</p>
<ul>
<li>EXE 文件位于 <code>dist/</code> 目录下。</li>
<li>将模型文件夹 <code>vosk-model-small-zh-cn-0.22</code> 复制到 EXE 同级目录。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>用 Tkinter 添加简易 GUI（跨平台)</strong></p>
<ul>
<li><p>代码如下</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tkinter <span class="keyword">as</span> tk</span><br><span class="line"><span class="keyword">from</span> tkinter <span class="keyword">import</span> filedialog, messagebox</span><br><span class="line"><span class="keyword">from</span> vosk <span class="keyword">import</span> Model, KaldiRecognizer</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VoskApp</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, root</span>):</span><br><span class="line">        <span class="variable language_">self</span>.root = root</span><br><span class="line">        root.title(<span class="string">&quot;Vosk 语音转字幕工具&quot;</span>)</span><br><span class="line">        root.geometry(<span class="string">&quot;500x300&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 模型路径设置</span></span><br><span class="line">        <span class="variable language_">self</span>.model_path = tk.StringVar(value=<span class="string">&quot;vosk-model-small-zh-cn-0.22&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># GUI 组件</span></span><br><span class="line">        tk.Label(root, text=<span class="string">&quot;音频文件:&quot;</span>).pack()</span><br><span class="line">        <span class="variable language_">self</span>.audio_entry = tk.Entry(root, width=<span class="number">50</span>)</span><br><span class="line">        <span class="variable language_">self</span>.audio_entry.pack()</span><br><span class="line">        tk.Button(root, text=<span class="string">&quot;浏览...&quot;</span>, command=<span class="variable language_">self</span>.browse_audio).pack()</span><br><span class="line"></span><br><span class="line">        tk.Label(root, text=<span class="string">&quot;输出字幕文件:&quot;</span>).pack()</span><br><span class="line">        <span class="variable language_">self</span>.output_entry = tk.Entry(root, width=<span class="number">50</span>)</span><br><span class="line">        <span class="variable language_">self</span>.output_entry.pack()</span><br><span class="line"></span><br><span class="line">        tk.Button(root, text=<span class="string">&quot;开始转换&quot;</span>, command=<span class="variable language_">self</span>.transcribe).pack()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">browse_audio</span>(<span class="params">self</span>):</span><br><span class="line">        filename = filedialog.askopenfilename(filetypes=[(<span class="string">&quot;音频文件&quot;</span>, <span class="string">&quot;*.wav *.mp3&quot;</span>)])</span><br><span class="line">        <span class="variable language_">self</span>.audio_entry.delete(<span class="number">0</span>, tk.END)</span><br><span class="line">        <span class="variable language_">self</span>.audio_entry.insert(<span class="number">0</span>, filename)</span><br><span class="line">        <span class="variable language_">self</span>.output_entry.delete(<span class="number">0</span>, tk.END)</span><br><span class="line">        <span class="variable language_">self</span>.output_entry.insert(<span class="number">0</span>, os.path.splitext(filename)[<span class="number">0</span>] + <span class="string">&quot;.srt&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">transcribe</span>(<span class="params">self</span>):</span><br><span class="line">        audio_file = <span class="variable language_">self</span>.audio_entry.get()</span><br><span class="line">        output_file = <span class="variable language_">self</span>.output_entry.get()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> audio_file <span class="keyword">or</span> <span class="keyword">not</span> output_file:</span><br><span class="line">            messagebox.showerror(<span class="string">&quot;错误&quot;</span>, <span class="string">&quot;请选择音频文件和输出路径！&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            model = Model(<span class="variable language_">self</span>.model_path.get())</span><br><span class="line">            rec = KaldiRecognizer(model, <span class="number">16000</span>)</span><br><span class="line">            rec.SetWords(<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">            process = subprocess.Popen(</span><br><span class="line">                [<span class="string">&quot;ffmpeg&quot;</span>, <span class="string">&quot;-loglevel&quot;</span>, <span class="string">&quot;quiet&quot;</span>, <span class="string">&quot;-i&quot;</span>, audio_file,</span><br><span class="line">                 <span class="string">&quot;-ar&quot;</span>, <span class="string">&quot;16000&quot;</span>, <span class="string">&quot;-ac&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;-f&quot;</span>, <span class="string">&quot;s16le&quot;</span>, <span class="string">&quot;-&quot;</span>],</span><br><span class="line">                stdout=subprocess.PIPE</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">            srt_content = []</span><br><span class="line">            index = <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                data = process.stdout.read(<span class="number">4000</span>)</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(data) == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> rec.AcceptWaveform(data):</span><br><span class="line">                    result = json.loads(rec.Result())</span><br><span class="line">                    <span class="keyword">if</span> <span class="string">&#x27;result&#x27;</span> <span class="keyword">in</span> result:</span><br><span class="line">                        words = result[<span class="string">&#x27;result&#x27;</span>]</span><br><span class="line">                        start = words[<span class="number">0</span>][<span class="string">&#x27;start&#x27;</span>]</span><br><span class="line">                        end = words[-<span class="number">1</span>][<span class="string">&#x27;end&#x27;</span>]</span><br><span class="line">                        text = <span class="string">&#x27; &#x27;</span>.join([w[<span class="string">&#x27;word&#x27;</span>] <span class="keyword">for</span> w <span class="keyword">in</span> words])</span><br><span class="line">                        srt_content.append(</span><br><span class="line">                            <span class="string">f&quot;<span class="subst">&#123;index&#125;</span>\n&quot;</span></span><br><span class="line">                            <span class="string">f&quot;<span class="subst">&#123;<span class="built_in">int</span>(start//<span class="number">3600</span>):02d&#125;</span>:<span class="subst">&#123;<span class="built_in">int</span>((start%<span class="number">3600</span>)//<span class="number">60</span>):02d&#125;</span>:<span class="subst">&#123;<span class="built_in">int</span>(start%<span class="number">60</span>):02d&#125;</span>,<span class="subst">&#123;<span class="built_in">int</span>((start%<span class="number">1</span>)*<span class="number">1000</span>):03d&#125;</span> --&gt; &quot;</span></span><br><span class="line">                            <span class="string">f&quot;<span class="subst">&#123;<span class="built_in">int</span>(end//<span class="number">3600</span>):02d&#125;</span>:<span class="subst">&#123;<span class="built_in">int</span>((end%<span class="number">3600</span>)//<span class="number">60</span>):02d&#125;</span>:<span class="subst">&#123;<span class="built_in">int</span>(end%<span class="number">60</span>):02d&#125;</span>,<span class="subst">&#123;<span class="built_in">int</span>((end%<span class="number">1</span>)*<span class="number">1000</span>):03d&#125;</span>\n&quot;</span></span><br><span class="line">                            <span class="string">f&quot;<span class="subst">&#123;text&#125;</span>\n\n&quot;</span></span><br><span class="line">                        )</span><br><span class="line">                        index += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(output_file, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                f.writelines(srt_content)</span><br><span class="line"></span><br><span class="line">            messagebox.showinfo(<span class="string">&quot;成功&quot;</span>, <span class="string">f&quot;字幕已生成：<span class="subst">&#123;output_file&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            messagebox.showerror(<span class="string">&quot;错误&quot;</span>, <span class="string">f&quot;转换失败：<span class="subst">&#123;<span class="built_in">str</span>(e)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    root = tk.Tk()</span><br><span class="line">    app = VoskApp(root)</span><br><span class="line">    root.mainloop()</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>打包带 GUI 的 EXE</strong></p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pyinstaller --onefile --windowed --icon=app.ico gui_app.py</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>用 Electron 或 PyQt 构建桌面应用</strong></p>
<ul>
<li><strong>PyQt（Python）</strong><ol>
<li><p>安装 PyQt5：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip3 install pyqt5</span><br></pre></td></tr></table></figure>
</li>
<li><p>将 Tkinter 代码迁移到 PyQt（类似逻辑，界面更美观）。</p>
</li>
<li><p>用 PyInstaller 打包（同方案1）。</p>
</li>
</ol>
</li>
<li><strong>Electron（JavaScript）</strong><ul>
<li><ol>
<li>用 <code>python-shell</code> 调用 Python 脚本：</li>
</ol>
  <figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line">   <span class="keyword">const</span> &#123; <span class="title class_">PythonShell</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;python-shell&#x27;</span>);</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">transcribe</span>(<span class="params">audioPath</span>) &#123;</span><br><span class="line">       <span class="keyword">let</span> options = &#123;</span><br><span class="line">           <span class="attr">scriptPath</span>: <span class="string">&#x27;path/to/script&#x27;</span>,</span><br><span class="line">           <span class="attr">args</span>: [audioPath]</span><br><span class="line">       &#125;;</span><br><span class="line">       <span class="title class_">PythonShell</span>.<span class="title function_">run</span>(<span class="string">&#x27;vosk_transcribe.py&#x27;</span>, options, <span class="function">(<span class="params">err, results</span>) =&gt;</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">           <span class="variable language_">console</span>.<span class="title function_">log</span>(results);</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>打包 Electron 应用：  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install electron-packager -g</span><br><span class="line">electron-packager . VoskApp --platform=win32 --<span class="built_in">arch</span>=x64</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>用 Docker 容器化（跨平台）</strong></p>
  <figure class="highlight docker"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.9</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip install vosk ffmpeg-python</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> vosk-model-small-zh-cn-0.22 /app/model</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> vosk_transcribe.py /app/</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;python&quot;</span>, <span class="string">&quot;vosk_transcribe.py&quot;</span>]</span></span><br></pre></td></tr></table></figure>
<p>  构建并运行：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -t vosk-app .</span><br><span class="line">docker run -v $(<span class="built_in">pwd</span>)/audio:/app/audio vosk-app</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
</search>
